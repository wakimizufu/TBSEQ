//
//    FILE: FRAM11_test.ino
//  AUTHOR: Rob Tillaart
// PURPOSE: demo FRAM11 memory test
//     URL: https://github.com/RobTillaart/FRAM_I2C


#include "FRAM.h"

FRAM11 fram;

uint32_t start;
uint32_t stop;

uint32_t sizeInBytes = 0;




	/*
	トラック情報 ビットストリーム
	☆総バイト数  :0x019F=416Byte
		0x0000:trackMap開始
			0x0000:トラック1
			0x0020:トラック2
			0x0040:トラック3
			0x0060:トラック4
			0x0080:トラック5
			0x00A0:トラック6
			0x00C0:トラック7
			0x00E0:トラック8
			0x0100:トラック9
			0x0120:トラック10
			0x0140:トラック11
			0x0160:トラック12
			0x0180:トラック13

		0x0000:トラック
			0x0000:演奏パターン1
			0x0002:演奏パターン2
			0x0004:演奏パターン3
			0x0006:演奏パターン4
			0x0008:演奏パターン5
			0x000A:演奏パターン6
			0x000C:演奏パターン7
			0x000E:演奏パターン8
			0x0010:演奏パターン9
			0x0012:演奏パターン10
			0x0014:演奏パターン11
			0x0016:演奏パターン12
			0x0018:演奏パターン13
			0x001A:演奏パターン14
			0x001C:演奏パターン15
			0x001E:演奏パターン16

		[ステップ]
		1Byte:
			bit6-7:(未使用:全て0)
			bit  5:最終ステップ(最終ステップ:1,通常ステップ:0)
			bit4-3:演奏バンク(1～4:0x0～0x3)
			bit2-0:演奏パターン(1～8:0x0～0x7)

		1Byte:
			bit4-7:(未使用:全て0)
			bit3-0:転調(NOTE_PWM_INDEX::NOTE_C2～NOTE_PWM_INDEX::NOTE_C3⇒0x0～0xD を設定)
	*/

  #define TRACKMAP_START_ADDR 0x400

	#define TRACKMAP_ALLBYTE 416
	unsigned char track_preset_bitstream[TRACKMAP_ALLBYTE]{
	0x00,0x00, 0x01,0x00, 0x02,0x00, 0x03,0x00, 0x04,0x00, 0x05,0x00, 0x06,0x00, 0x07,0x00, 0x00,0x00, 0x01,0x00, 0x02,0x00, 0x03,0x00, 0x04,0x00, 0x05,0x00, 0x06,0x00, 0x27,0x00,	//トラック1
	0x08,0x00, 0x09,0x00, 0x0A,0x00, 0x0B,0x00, 0x0C,0x00, 0x0D,0x00, 0x0E,0x00, 0x0F,0x00, 0x08,0x00, 0x09,0x00, 0x0A,0x00, 0x0B,0x00, 0x0C,0x00, 0x0D,0x00, 0x0E,0x00, 0x2F,0x00,	//トラック2
	0x10,0x00, 0x11,0x00, 0x12,0x00, 0x13,0x00, 0x14,0x00, 0x15,0x00, 0x16,0x00, 0x17,0x00, 0x10,0x00, 0x11,0x00, 0x12,0x00, 0x13,0x00, 0x14,0x00, 0x15,0x00, 0x16,0x00, 0x37,0x00,	//トラック3
	0x18,0x00, 0x19,0x00, 0x1A,0x00, 0x1B,0x00, 0x1C,0x00, 0x1D,0x00, 0x1E,0x00, 0x1F,0x00, 0x18,0x00, 0x19,0x00, 0x1A,0x00, 0x1B,0x00, 0x1C,0x00, 0x1D,0x00, 0x1E,0x00, 0x3F,0x00,	//トラック4
	0x00,0x02, 0x01,0x02, 0x02,0x02, 0x03,0x02, 0x04,0x02, 0x05,0x02, 0x06,0x02, 0x07,0x02, 0x00,0x02, 0x01,0x02, 0x02,0x02, 0x03,0x02, 0x04,0x02, 0x05,0x02, 0x06,0x02, 0x27,0x02,	//トラック5
	0x08,0x02, 0x09,0x02, 0x0A,0x02, 0x0B,0x02, 0x0C,0x02, 0x0D,0x02, 0x0E,0x02, 0x0F,0x02, 0x08,0x02, 0x09,0x02, 0x0A,0x02, 0x0B,0x02, 0x0C,0x02, 0x0D,0x02, 0x0E,0x02, 0x2F,0x02,	//トラック6
	0x10,0x02, 0x11,0x02, 0x12,0x02, 0x13,0x02, 0x14,0x02, 0x15,0x02, 0x16,0x02, 0x17,0x02, 0x10,0x02, 0x11,0x02, 0x12,0x02, 0x13,0x02, 0x14,0x02, 0x15,0x02, 0x16,0x02, 0x37,0x02,	//トラック7
	0x18,0x02, 0x19,0x02, 0x1A,0x02, 0x1B,0x02, 0x1C,0x02, 0x1D,0x02, 0x1E,0x02, 0x1F,0x02, 0x18,0x02, 0x19,0x02, 0x1A,0x02, 0x1B,0x02, 0x1C,0x02, 0x1D,0x02, 0x1E,0x02, 0x3F,0x02,	//トラック8
	0x00,0x05, 0x01,0x05, 0x02,0x05, 0x03,0x05, 0x04,0x05, 0x05,0x05, 0x06,0x05, 0x07,0x05, 0x00,0x05, 0x01,0x05, 0x02,0x05, 0x03,0x05, 0x04,0x05, 0x05,0x05, 0x06,0x05, 0x27,0x05,	//トラック9
	0x08,0x05, 0x09,0x05, 0x0A,0x05, 0x0B,0x05, 0x0C,0x05, 0x0D,0x05, 0x0E,0x05, 0x0F,0x05, 0x08,0x05, 0x09,0x05, 0x0A,0x05, 0x0B,0x05, 0x0C,0x05, 0x0D,0x05, 0x0E,0x05, 0x2F,0x05,	//トラック10
	0x10,0x05, 0x11,0x05, 0x12,0x05, 0x13,0x05, 0x14,0x05, 0x15,0x05, 0x16,0x05, 0x17,0x05, 0x10,0x05, 0x11,0x05, 0x12,0x05, 0x13,0x05, 0x14,0x05, 0x15,0x05, 0x16,0x05, 0x37,0x05,	//トラック11
	0x18,0x05, 0x19,0x05, 0x1A,0x05, 0x1B,0x05, 0x1C,0x05, 0x1D,0x05, 0x1E,0x05, 0x1F,0x05, 0x18,0x05, 0x19,0x05, 0x1A,0x05, 0x1B,0x05, 0x1C,0x05, 0x1D,0x05, 0x1E,0x05, 0x3F,0x05,	//トラック12
	0x00,0x0D, 0x01,0x0D, 0x02,0x0D, 0x03,0x0D, 0x04,0x0D, 0x05,0x0D, 0x06,0x0D, 0x07,0x0D, 0x00,0x0D, 0x01,0x0D, 0x02,0x0D, 0x03,0x0D, 0x04,0x0D, 0x05,0x0D, 0x06,0x0D, 0x27,0x0D	//トラック13	
	};


void setup()
{
   delay(2000);

  Serial.begin(115200);
  Serial.println(__FILE__);
  Serial.print("FRAM_LIB_VERSION: ");
  Serial.println(FRAM_LIB_VERSION);

  Wire.begin();

  int rv = fram.begin(0x50);

  Serial.print("rv:\t");
  Serial.println(rv);

  if (rv != 0)
  {
    Serial.print("INIT ERROR: ");
    Serial.println(rv);
  }

  //  get size
  Serial.print("   KB  :\t");
  Serial.println(fram.getSize());
  Serial.print("BYTES  :\t");
  Serial.println(fram.getSizeBytes());
  sizeInBytes = fram.getSizeBytes();


  delay(100);

  test();

  Serial.println("done...");
}


void loop()
{
}


void test()
{
  //  addr goes from 0 .. 2047
  //  value goes from 0.. 255

  uint8_t value = 0x00;
  uint32_t index, addr;

  // read back
  for (index = 0; index < (TRACKMAP_START_ADDR+TRACKMAP_ALLBYTE); index++)
  {
    addr	=	index;
    value = fram.read8(addr);

    Serial.print("trackMap::Read\t");
    Serial.print(addr,HEX);
    Serial.print("\t");
    Serial.println(value,HEX);
    delay(10);
  }
  
//return;


  for (index = 0; index < TRACKMAP_ALLBYTE; index++)
  {
    value	=	track_preset_bitstream[index];
    addr	=	TRACKMAP_START_ADDR + index;

    fram.write8(addr, value);
    Serial.print("trackMap::Write\t");
    Serial.print(addr,HEX);
    Serial.print("\t");
    Serial.println(value,HEX);
    delay(10);
  }


  // read back
  for (index = 0; index < TRACKMAP_ALLBYTE; index++)
  {
    addr	=	TRACKMAP_START_ADDR + index;
    value = fram.read8(addr);

    Serial.print("trackMap::Read\t");
    Serial.print(addr,HEX);
    Serial.print("\t");
    Serial.println(value,HEX);
    delay(10);
  }


}

//  -- END OF FILE --
